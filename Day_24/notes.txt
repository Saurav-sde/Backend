redis store data in form of key:value pair.
redis automatically delete the data after given timestamps.

why it need data in key:value pair, mongoDb store in form of documnet, SQL store in the form of rows
=> Redis store in Key:value so that it can easily find items
the data is getting stored in RAM ,and stores in key:value so that it can use hashmap and then, we can fetch data more efficiently. retrieve data in O(1).
redis does want heavy data it always wants light data.
key must be unique, always try to keep meaningful name of key.

npm i redis
// code setup
const redis = require('redis');
const redisClient = redis.createClient({
    username: 'default',
    password: 'C6Lywg3TJOvqc5TLDAkkA4iQVeiaGi05',
    socket: {
        host: 'redis-10536.crce182.ap-south-1-1.ec2.redns.redis-cloud.com',
        port: 10536
    }
});
module.exports = redisClient;

await redisClient.connect(); // to connect to redis


// always start server when all the database is connected(redis, mongoDb)
const InitializeConnection = async() => {
    try {
        await Promise.all([redisClient.connect(),main()]); // here both are connecting parallely
        app.listen(process.env.PORT,()=>{
            console.log("Listening at port 3000");
        })
    } catch (err) {
        console.log("Error: " + err);
    }
}
InitializeConnection();


authRouter.post("/logout",userAuth,async(req,res) => {
    try {

        const {token} = req.cookies;

        const payload = jwt.decode(token);
        
        await redisClient.set(`token:${token}`, "Blocked");
        // await redisClient.expire(`token:${token}`,1800); // valid from current time to 1800sec 
        await redisClient.expireAt(`token:${token}`,payload.exp); // 01/01/1970 se ka tak valid rahega

        res.cookie("token",null,{expires: new Date(Date.now())});
        res.send("Logout Successfully!");
    } catch (err) {
        res.send("Error : "+ err.message);
    }
})
await redisClient.expire(`token:${token}`,1800); :- if we use this for expiry then we have hardcoded the expiry of token to 30min. suppose any token whose expiry is 3day but we have removed from redis db after 30 min , then client gets the access after 30min using this token. so we can't hardcode it.

so we use 
const payload = jwt.decode(token); // this gives the paylad , it contains the creation and expiry date of the token in seconds from 01/01/1970
payload.exp; // this will give the actual expiry time of the token in seconds from 01/01/1970.
await redisClient.expireAt(`token:${token}`,payload.exp); 


user can send any token can we store it in blocked token, the answer is no as it will corrupt the db.
so first we have to validate the token that it is generated by me or not.
whenever user logouts i have to authenticate the user.

we have to write this code in user authentication 
const isBlocked = await redisClient.exists(`token:${token}`); // it return true when the token is present in redisdb
if(isBlocked)
    throw new Error("Invalid Token"); 

now for evry req we have to check token is blocked or not, so we can write in middleware i.e userAuth here

in token we put the expiry time but why the creation time is automatically kept by the system??
if system doesn't put creation time in token then all the created token looks like same for a user as evry time the payload is same(id and emailID is same of a user , expirydate is always same) in every login time, so all the created token is same 

header.payload
{
    id:123,
    emailId: "xyz@gamil.com"
}
digital signature
every time header and digital signature is same

header.payload
{
    id:123,
    emailId: "xyz@gamil.com",
    iat:3267814
}
digital signature
Now every time completely different token is generated


what do you mean by late limiter and why it is necesssary?
suppose an user is sends get request 10000 times in 1 minute, we have to avoid it.
Here rateLimiter came to help us in this situation. by limiting the req of a user like a user only send 60 req in 1 hour.